**7-4 Dijkstra Sequence (30 分)**


Dijkstra's algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.

In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let's call it **Dijkstra sequence**, is generated by Dijkstra's algorithm.

On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both `{ 5, 1, 3, 4, 2 }` and `{ 5, 3, 1, 2, 4 }` are Dijkstra sequences for the graph, where `5` is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.

### Input Specification:
Each input file contains one test case. For each case, the first line contains two positive integers <code>N<sub>v</sub></code> (≤10<sup>3</sup>) and <code>N<sub>e</sub></code> (≤10<sup>5</sup>), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <code>N<sub>v</sub></code> .
Then <code>N​<sub>e</sub></code> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.

Finally the number of queries, K, is given as a positive integer no larger than 100, followed by K lines of sequences, each contains a permutationof the <code>N<sub>v</sub></code> vertices. It is assumed that the first vertex is the source for each sequence.

All the inputs in a line are separated by a space.

### Output Specification:
For each of the K sequences, print in a line `Yes` if it is a Dijkstra sequence, or `No` if not.

### Sample Input:
```
5 7
1 2 2
1 5 1
2 3 1
2 4 1
2 5 2
3 5 1
3 4 1
4
5 1 3 4 2
5 3 1 2 4
2 3 4 5 1
3 2 1 5 4
```
### Sample Output:
```
Yes
Yes
Yes
No
```

i> 题意
给你一张图，并给你一串序列，判断该序列是否是迪杰斯特拉序列。迪杰斯特拉序列：在迪杰斯特拉算法中，找到一个距离已访问过的点集最近的点，并对与该点相连且能通过该点优化距离的点进行优化所形成了点序列。

i> 思路
我第一反应的话就是模拟迪杰斯特拉看看能不能过全部点。
在搜寻未访问且距离最小的点时，若有距离都为最小的话，需要都放入最小点容器中，这样判断所给序列的当前点是否在最小点容器中，如果不在说明不是迪杰斯特拉序列，否则进行优化距离，并判断所给序列下一个点，进入下一轮循环。循环结束无问题则是迪杰斯特拉序列。
感觉很耿直。。没啥坑点

```
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <string>
#include <unordered_map>
#include <math.h>
#define maxsize 1002
#define INF 99999999
using namespace std;
int n, m, matrx[maxsize][maxsize] = {0}, d[maxsize];
bool vis[maxsize] = {false};
vector<int> now;
void check()
{
    fill(d + 1, d + 1 + n, INF);
    fill(vis + 1, vis + 1 + n, false);
    d[now[0]] = 0;
    set<int> tmp;
    int index = 0;
    for (int i = 0; i < n; i++)
    {
        int u, mini = INF;
        for (int j = 1; j <= n; j++)
            if (vis[j] == false)
            {
                if (d[j] < mini)
                {
                    mini = d[j];
                    tmp.clear();
                    tmp.insert(j);
                }
                else if (d[j] == mini)
                    tmp.insert(j);
            }
        if (tmp.find(now[index]) != tmp.end())
        {
            vis[now[index]] = true;
            u = now[index];
            tmp.clear();
        }
        else
        {
            cout << "No" << endl;
            return;
        }
        for (int j = 1; j <= n; j++)
            if (vis[j] == false && matrx[u][j] != 0 && d[j] > d[u] + matrx[u][j])
                d[j] = d[u] + matrx[u][j];
        index++;
    }
    cout << "Yes" << endl;
}
int main()
{
    std::iostream::sync_with_stdio(false);
    std::cin.tie(0);

    cin >> n >> m;
    int a, b, c;
    for (int i = 0; i < m; i++)
    {
        cin >> a >> b >> c;
        matrx[a][b] = matrx[b][a] = c;
    }
    cin >> m;
    for (int i = 0; i < m; i++)
    {
        now.clear();
        for (int j = 0; j < n; j++)
        {
            cin >> a;
            now.push_back(a);
        }
        check();
    }
    return 0;
}
```

![PAT-2019年秋季考试-甲级 7-4 Dijkstra Sequence.png][1]


[1]: http://alomerry.com/usr/uploads/2020/01/3353628652.png